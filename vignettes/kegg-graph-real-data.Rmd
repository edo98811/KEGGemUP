---
title: "kegg-graph"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{kegg-graph}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

If you dont have the package installed you can do so by running:

```{r install-package, eval=FALSE}
install.packages("remotes")     
remotes::install_github("edo98811/KEGGemUP")
```

The load it.

```{r}
library("KEGGemUP")
```

KEGG pathways are used in many bioinformatics contexts, this package package can make it very easy to implement these in the analysis of real data.
A very important part of bioinformatics analyses is both data integration and visiazionation. KEGGemUP aims to facilitate these tasks by providing functions to parse KEGG pathways and build graph objects, the idea is then to use these graph to map on them thre results of differential expression analyses.

These vignette assumes you have already performed a differential expression analysis and have the results available as a `data.frame` or a result object from `limma` or `DESeq2`. To reproduce this situation we will now build a examplary differential expression results using the macrophage dataset from the macrophage package.

<details>
<summary> Setting up the data </summary>

KEGG pathways are used in many bioinformatics contexts, this package package can make it very easy to implement these in the analysis of real data.
A very important part of bioinformatics analyses is both data integration and visiazionation. KEGGemUP aims to facilitate these tasks by providing functions to parse KEGG pathways and build graph objects, the idea is then to use these graph to map on them thre results of differential expression analyses.

These vignette assumes you have already performed a differential expression analysis and have the results available as a `data.frame` or a result object from `limma` or `DESeq2`. To reproduce this situation we will now build a examplary differential expression results using the macrophage dataset from the macrophage package.

<details>
<summary> Setting up the data </summary>

```{r load-fake-results}
message("--- Loading packages...")

suppressPackageStartupMessages({
  library("macrophage")
  library("DESeq2")
  library("org.Hs.eg.db")
  library("AnnotationDbi")
  library("clusterProfiler")
  library("limma")
  library("edgeR")
})
message("- Done!")

# Load the macrophage dataset ---------------------------------------------------
data(gse)
rownames(gse) <- substr(rownames(gse), 1, 15)  # truncate rownames at 15 characters

# DESeq2 analysis ---------------------------------------------------------------
dds <- DESeqDataSet(gse, design = ~ condition)

# Filter low counts
keep <- rowSums(counts(dds) >= 10) >= 6
dds <- dds[keep, ]

dds <- DESeq(dds)

# limma analysis ---------------------------------------------------------------
condition <- factor(colData(gse)[, "condition_name"])
design <- model.matrix(~0 + condition)

contrast.matrix <- makeContrasts(
  IFNg_vs_naive = conditionIFNg - conditionnaive,
  levels = design
)

dge <- DGEList(assay(gse))
dge <- calcNormFactors(dge)

cutoff <- 1
drop <- which(apply(cpm(dge), 1, max) < cutoff)
dge <- dge[-drop, ]

voom_mat <- voom(dge, design, plot = FALSE)
fit <- lmFit(voom_mat, design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)  # Empirical Bayes moderation

# Gene annotation ---------------------------------------------------------------

anns <- AnnotationDbi::select(
  org.Hs.eg.db,
  keys = rownames(dds),
  columns = c("SYMBOL", "ENTREZID"),
  keytype = "ENSEMBL",
  multiVals = "first"
)

# DESeq2 results ---------------------------------------------------------------
res_macrophage_IFNg_vs_naive_dds <- results(
  dds,
  contrast = c("condition", "IFNg", "naive"),
  lfcThreshold = 1,
  alpha = 0.05
)

summary(res_macrophage_IFNg_vs_naive_dds) 

res_macrophage_IFNg_vs_naive_dds$SYMBOL <- rowData(dds)$SYMBOL
res_macrophage_IFNg_vs_naive_dds$ENTREZID <- anns$ENTREZID[match(rownames(res_macrophage_IFNg_vs_naive_dds), anns$ENSEMBL)]

# limma results ---------------------------------------------------------------
res_macrophage_IFNg_vs_naive_limma <- topTable(
  fit2,
  coef = "IFNg_vs_naive",
  adjust = "fdr",
  number = Inf,
  confint = TRUE
)

res_macrophage_IFNg_vs_naive_limma$ENTREZID <- anns$ENTREZID[match(rownames(res_macrophage_IFNg_vs_naive_limma), anns$ENSEMBL)]

# Enrichment analysis ----------------------------------------------------------
de_entrez_IFNg_vs_naive_genes <- anns $ENTREZID[
  (!is.na(res_macrophage_IFNg_vs_naive_dds$padj)) &
    (res_macrophage_IFNg_vs_naive_dds$padj <= 0.05)
]

res_enrich_IFNg_vs_naive_dds <- enrichKEGG(
  gene = de_entrez_IFNg_vs_naive_genes,
  organism = "hsa",
  pvalueCutoff = 0.05
)@result

```

</details>

## Functions to parse KGML files

KGML is the format that KEGG uses to save the pathway structure and it is what this package interfaces itself with. 

You can use these functions to parse KGML files directly. From these you can build a graph object if you wish to do so and you have expertise with graph analysis in R.


```{r kgml-parsing}
nodes_df <- parse_kgml_entries(system.file("extdata", "hsa04010.xml", package = "KEGGemUP"))
edges_df <- parse_kgml_relations(system.file("extdata", "hsa04010.xml", package = "KEGGemUP"))
```

### The output data.frame frame for nodes

Here you can see the first 5 columns of the dataframe that you get by parsing the nodes from a KGML file. It is a `data.frame` where each row represents a node in the KEGG pathway graph. No operations are done on the data, it is just a direct parsing of the KGML file.

```{r}
knitr::kable(head(nodes_df))
```

### The output data.frame frame for edges

Here you can see the first 5 columns of the dataframe that you get by parsing the edges from a KGML file. It is a `data.frame` where each row represents an edge in the KEGG pathway graph. No operations are done on the data, it is just a direct parsing of the KGML file.

```{r}
knitr::kable(head(edges_df))
```

## Build a graph from a pathway ID and map results to nodes
To map the differential expression results to the nodes of a KEGG pathway graph you can use `map_results_to_graph()`. The input of this function is a graph object built with `kegg_to_graph()` and a list of differential expression results tables or a single differential expression results table.

You can also pass as input to `map_results_to_graph()` a single `data.frame` with the differential expression results. This dataframe must contain at least two columns: one with the KEGG feature IDs (without organism prefix) and another with the values to map to the nodes (e.g., log2 fold changes). You can pass to the function the names of these columns if they differ from the default ones with the parameters `feature_column` and `value_column`.

Note that the KEGG IDs without organism prefix are the the ENTREZ IDs for genes. For other feature types (e.g., compounds) you will need to make sure that the IDs in your differential expression results table match the KEGG IDs used in the graph.

The defualt parameters are:

- `feature_column`: "KEGG_ids"
- `value_column`: "log2FoldChange"

If you have multiple differential expression results tables (for example if you have one metabolomics and one transcriptomics) to map to the nodes you can pass a list of lists. Each sublist must contain the following elements:

- `de_table`: a data.frame with the differential expression results.
- `value_column`: the name of the column in de_table containing the values to map to the nodes.
- `feature_column`: the name of the column in de_table containing the feature IDs (e.g., ENTREZ IDs) that correspond to the KEGG ids in the graph (without organism prefix).

```{r}
de_results_list <-list(
  trans_limma = list(
    de_table = data.frame(res_macrophage_IFNg_vs_naive_limma),
    value_column = "logFC",
    feature_column = "ENTREZID"
  ),
  trans_deseq = list(
    de_table = data.frame(res_macrophage_IFNg_vs_naive_dds),
    value_column = "log2FoldChange",
    feature_column = "ENTREZID"
    )
)
```


### Example of usage with the list of DE results tables

We will now take a KEGG pathway from the enrichment results we built earlier and map the differential expression results to its nodes. As you can see you simply need to pass to the function the graph object and the list of differential expression results tables that we defined before.

```{r use-package}
pathway <- rownames(res_enrich_IFNg_vs_naive_dds)[6]
graph <- kegg_to_graph(pathway)
graph <- map_results_to_graph(graph, de_results_list)
graph
```


### Example of usage with a single DE results table

Let's first build a filtered differential expression results table with only the significant results.

```{r}
de_results_limma <-  data.frame(res_macrophage_IFNg_vs_naive_limma)
```

Then we will call the function with this table as input. The parameter `feature_column` and `value_column` are set to match the column names in our differential expression results table.

```{r use-package-2}
graph <- kegg_to_graph(pathway)
graph <- map_results_to_graph(graph, de_results_limma, feature_column = "ENTREZID", value_column = "logFC")
graph
```

```{r}
sessionInfo()
```